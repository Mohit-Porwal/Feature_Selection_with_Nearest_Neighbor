# -*- coding: utf-8 -*-
"""CS205_Project_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q8QnLipZrRU4wSt-TbaaeaNz4t271KhF
"""

import numpy as np
import matplotlib.pyplot as plt
import time
import math

accuracy_tracker_for_plot = []
number_of_features_tracker_for_plot = []

def leave_one_out_cross_validation(tabular,current_set_of_features_2,feature_to_add,algo_choice):

  number_of_correctly_classified = 0
  temp = current_set_of_features_2[:]
  temp = list(temp)

  if algo_choice == 1:
    temp.append(feature_to_add)
  else:
    temp.remove(feature_to_add)
  
  for loo in range(0,len(tabular)):
    training_set = tabular[:]
    testing_set = training_set[loo]
    nearest_class = []
    count = 0
    min_distance = 100000000000
    min_class = 1.0
    for nn in training_set:
      if count==loo:
        count += 1
        continue
      euclidean_distance = 0
      count += 1
      for ed in temp:
        euclidean_distance = euclidean_distance + (((nn[ed]) - (testing_set[ed])) * ((nn[ed]) - (testing_set[ed])))
      final_euclid = math.sqrt(euclidean_distance)
      if final_euclid < min_distance:
        min_distance = final_euclid
        min_class = nn[0]
    if(testing_set[0]==min_class):
      number_of_correctly_classified += 1
  accu_accu = number_of_correctly_classified / (len(tabular))
  return accu_accu

def Forward_Search(tabular,algo_choice):

  global accuracy_tracker_for_plot, number_of_features_tracker_for_plot
  current_set_of_features = []
  number_of_features = len(tabular[0])
  accuracy_finale = 0
  feature_finale = []

  for outer_level in range(1,number_of_features):
    feature_to_add_to_this_level = []
    best_so_far_accuracy = 0

    for inner in range(1,number_of_features):
      if inner not in current_set_of_features:
        accuracy = leave_one_out_cross_validation(tabular,current_set_of_features,inner,algo_choice)
        print ("     Using feature(s) ["+str(inner)+"] accuracy is "+str(accuracy))
        if accuracy > best_so_far_accuracy:
          best_so_far_accuracy = accuracy
          feature_to_add_to_this_level = inner

    if not feature_to_add_to_this_level == False:
        current_set_of_features.append(feature_to_add_to_this_level)
        print ("On level "+str(outer_level)+" I added feature "+ str(feature_to_add_to_this_level) + " to current set")
        accuracy_tracker_for_plot.append(best_so_far_accuracy)
        number_of_features_tracker_for_plot.append(len(current_set_of_features))
        print(accuracy_tracker_for_plot)
        print(number_of_features_tracker_for_plot)
    if best_so_far_accuracy > accuracy_finale:
        feature_finale = current_set_of_features[:]
        accuracy_finale = best_so_far_accuracy

  print("The forward search has ended with the most appropriate subset of features as: \n")
  print(feature_finale)
  print("The accuracy for the above set of features is: \n")
  print(accuracy_finale)

def Backward_Elimination(tabular,algo_choice):

  global accuracy_tracker_for_plot, number_of_features_tracker_for_plot
  current_set_of_features = range(1,len(tabular[0]))
  number_of_features = len(tabular[0])
  accuracy_tracker_for_plot = []
  accuracy_finale = 0

  for outer_level in range(1,number_of_features):
    feature_to_eliminate_from_this_level = []
    best_so_far_accuracy = 0

    for inner in range(number_of_features):
      if inner in current_set_of_features:
        accuracy = leave_one_out_cross_validation(tabular,current_set_of_features,inner,algo_choice)
        if accuracy > best_so_far_accuracy:
          best_so_far_accuracy = accuracy
          feature_to_eliminate_from_this_level = inner

    if not feature_to_eliminate_from_this_level == False:
      current_set_of_features = list(current_set_of_features)
      current_set_of_features.remove(feature_to_eliminate_from_this_level)
      print ("On level "+str(outer_level)+" I removed feature "+ str(feature_to_eliminate_from_this_level) + " to current set")
      accuracy_tracker_for_plot.append(best_so_far_accuracy)
      number_of_features_tracker_for_plot.append(len(current_set_of_features))
      print(accuracy_tracker_for_plot)
      print(number_of_features_tracker_for_plot)
    if best_so_far_accuracy > accuracy_finale:
        feature_finale = current_set_of_features[:]
        accuracy_finale = best_so_far_accuracy

  print("The backward elimination search has ended with the most appropriate subset of features as: \n")
  print(feature_finale)
  print("The accuracy for the above set of features is: \n")
  print(accuracy_finale)

def plot(accuracy_tracker_for_plot,number_of_features_tracker_for_plot,algo_choice):

    plt.figure(figsize=(10, 3))
    plt.bar(number_of_features_tracker_for_plot, accuracy_tracker_for_plot)
    plt.xlabel("Number of features in the subset")
    plt.ylabel("Accuracies")
    if algo_choice==1:
      plt.title("Number of features in the subset vs Accuracy in Forward Search")
    else:
      plt.title("Number of features in the subset vs Accuracy in Backward Search")
    plt.draw()

if __name__ == '__main__':
  file = np.loadtxt("CS205_SP_2022_SMALLtestdata__27.txt",dtype=float)

  print("Please choose one of the following algorithms: \n")
  print("1. Forward Search \n 2. Backward Elimination \n")

  algo_choice = int(input("Enter 1 for Forward Search OR Enter 2 for Backward Elimination \n"))

  begin = time.time()
  if algo_choice==1:
    Forward_Search(file,algo_choice)
  elif algo_choice==2:
    Backward_Elimination(file,algo_choice)
  else:
    print("Incorrect choice!!! Duh?!")
  terminate = time.time()
  
  print("This program ran for a total of", '%.2f' % (terminate - begin),"seconds")

  plot(accuracy_tracker_for_plot,number_of_features_tracker_for_plot,algo_choice)
